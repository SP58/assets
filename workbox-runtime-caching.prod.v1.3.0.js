this.workbox=this.workbox||{},function(e){"use strict";const t={"multiple-cache-will-update-plugins":"You cannot register more than one plugin that implements cacheWillUpdate.","multiple-cache-will-match-plugins":"You cannot register more than one plugin that implements cacheWillMatch.","invalid-response-for-caching":"The fetched response could not be cached due to an invalid response code.","no-response-received":"No response received; falling back to cache.","bad-cache-id":"The 'cacheId' parameter must be a string with at least one character."};var s=new class{constructor(e){this._errors=e}createError(e,t){if(!(e in this._errors))throw new Error(`Unable to generate error '${e}'.`);let s=this._errors[e].replace(/\s+/g," "),a=null;t&&(s+=` [${t.message}]`,a=t.stack);const r=new Error;return r.name=e,r.message=s,r.stack=a,r}}(t),a={parse:()=>[]};function r(e){const t=Object.keys(e);t.some((t=>void 0!==e[t]))||n("Please set at least one of the following parameters: "+t.map((e=>`'${e}'`)).join(", "))}function i(e,t){const s=Object.keys(e).pop();e[s]instanceof t||n(`The '${s}' parameter must be an instance of\n      '${t.name}'`)}function c(e,t){const s=Object.keys(e).pop(),a=typeof e[s];a!==t&&n(`The '${s}' parameter has the wrong type. (Expected:\n      ${t}, actual: ${a})`)}function o(e,t){const s=Object.keys(e).pop(),a=`The '${s}' parameter should be an array containing\n    one or more '${t}' elements.`;Array.isArray(e[s])||n(a);for(let r of e[s])typeof r!==t&&n(a)}function n(e){e=e.replace(/\s+/g," ");const t=new Error(e);t.name="assertion-failed";const s=a.parse(t);throw 3<=s.length&&(t.message=`Invalid call to ${s[2].functionName}() â€” `+e),t}class h{constructor(){this._logs=[],this._childGroups=[],this._isFallbackMode=!1;const e=/Firefox\/(\d*)\.\d*/.exec(navigator.userAgent);if(e)try{55>parseInt(e[1],10)&&(this._isFallbackMode=!0)}catch(e){this._isFallbackMode=!0}/Edge\/\d*\.\d*/.exec(navigator.userAgent)&&(this._isFallbackMode=!0)}addPrimaryLog(e){this._primaryLog=e}addLog(e){this._logs.push(e)}addChildGroup(e){0===e._logs.length||this._childGroups.push(e)}print(){return 0===this._logs.length&&0===this._childGroups.length?void this._printLogDetails(this._primaryLog):(this._primaryLog&&(this._isFallbackMode?this._printLogDetails(this._primaryLog):console.groupCollapsed(...this._getLogContent(this._primaryLog))),this._logs.forEach((e=>{this._printLogDetails(e)})),this._childGroups.forEach((e=>{e.print()})),void(this._primaryLog&&!this._isFallbackMode&&console.groupEnd()))}_printLogDetails(e){(e.logFunc?e.logFunc:console.log)(...this._getLogContent(e))}_getLogContent(e){let t=e.message;this._isFallbackMode&&"string"==typeof t&&(t=t.replace(/%c/g,""));let s=[t];return!this._isFallbackMode&&e.colors&&(s=s.concat(e.colors)),e.args&&(s=s.concat(e.args)),s}}self.workbox=self.workbox||{},self.workbox.LOG_LEVEL=self.workbox.LOG_LEVEL||{none:-1,verbose:0,debug:1,warn:2,error:3};const l="#bdc3c7";var u=new class{constructor(){this._defaultLogLevel=self.workbox.LOG_LEVEL.warn}log(e){this._printMessage(self.workbox.LOG_LEVEL.verbose,e)}debug(e){this._printMessage(self.workbox.LOG_LEVEL.debug,e)}warn(e){this._printMessage(self.workbox.LOG_LEVEL.warn,e)}error(e){this._printMessage(self.workbox.LOG_LEVEL.error,e)}_printMessage(e,t){if(this._shouldLogMessage(e,t)){this._getAllLogGroups(e,t).print()}}_getAllLogGroups(e,t){const s=new h,a=this._getPrimaryMessageDetails(e,t);if(s.addPrimaryLog(a),t.error){const e={message:t.error,logFunc:console.error};s.addLog(e)}const r=new h;if(t.that&&t.that.constructor&&t.that.constructor.name){const e=t.that.constructor.name;r.addLog(this._getKeyValueDetails("class",e))}return t.data&&("object"!=typeof t.data||t.data instanceof Array?r.addLog(this._getKeyValueDetails("additionalData",t.data)):Object.keys(t.data).forEach((e=>{r.addLog(this._getKeyValueDetails(e,t.data[e]))}))),s.addChildGroup(r),s}_getKeyValueDetails(e,t){return{message:`%c${e}: `,colors:["color: #3498db"],args:t}}_getPrimaryMessageDetails(e,t){let s,a;e===self.workbox.LOG_LEVEL.verbose?(s="Info",a=l):e===self.workbox.LOG_LEVEL.debug?(s="Debug",a="#2ecc71"):e===self.workbox.LOG_LEVEL.warn?(s="Warn",a="#f1c40f"):e===self.workbox.LOG_LEVEL.error&&(s="Error",a="#e74c3c");let r=`%cðŸ”§ %c[${s}]`;const i=[`color: ${l}`,`color: ${a}`];let c;return"string"==typeof t?c=t:t.message&&(c=t.message),c&&(c=c.replace(/\s+/g," "),r+=`%c ${c}`,i.push("color: #7f8c8d; font-weight: normal")),{message:r,colors:i}}_shouldLogMessage(e,t){if(!t)return!1;let s=this._defaultLogLevel;return self&&self.workbox&&"number"==typeof self.workbox.logLevel&&(s=self.workbox.logLevel),!(s===self.workbox.LOG_LEVEL.none||e<s)}};class p{constructor({statuses:e,headers:t}={}){r({statuses:e,headers:t}),void 0!==e&&o({statuses:e},"number"),void 0!==t&&c({headers:t},"object"),this.statuses=e,this.headers=t}isResponseCacheable({request:e,response:t}={}){i({response:t},Response);let s=!0;if(this.statuses&&(s=this.statuses.includes(t.status)),this.headers&&s&&(s=Object.keys(this.headers).some((e=>t.headers.get(e)===this.headers[e]))),!s){const s={response:t};this.statuses&&(s["valid-status-codes"]=JSON.stringify(this.statuses)),this.headers&&(s["valid-headers"]=JSON.stringify(this.headers)),e&&(s.request=e),u.debug({message:"The response does not meet the criteria for being added to the\n          cache.",data:s})}return s}}class d extends p{cacheWillUpdate({request:e,response:t}={}){return this.isResponseCacheable({request:e,response:t})}}const g=({cacheId:e}={})=>{let t="workbox-runtime-caching";return e&&(t=`${e}-${t}`),self&&self.registration&&(t+=`-${self.registration.scope}`),t},f=["cacheDidUpdate","cacheWillMatch","cacheWillUpdate","fetchDidFail","requestWillFetch"];class m{constructor({cacheName:e,cacheId:t,plugins:a,fetchOptions:r,matchOptions:i}={}){if(t&&("string"!=typeof t||0===t.length))throw s.createError("bad-cache-id");e?(c({cacheName:e},"string"),this.cacheName=e,t&&(this.cacheName=`${t}-${this.cacheName}`)):this.cacheName=g({cacheId:t}),r&&(c({fetchOptions:r},"object"),this.fetchOptions=r),i&&(c({matchOptions:i},"object"),this.matchOptions=i),this.plugins=new Map,a&&(o({plugins:a},"object"),a.forEach((e=>{for(let t of f)if("function"==typeof e[t]){if(this.plugins.has(t)){if("cacheWillUpdate"===t)throw s.createError("multiple-cache-will-update-plugins");if("cacheWillMatch"===t)throw s.createError("multiple-cache-will-match-plugins")}else this.plugins.set(t,[]);this.plugins.get(t).push(e)}}))),this.plugins.has("cacheWillUpdate")&&(this._userSpecifiedCachableResponsePlugin=this.plugins.get("cacheWillUpdate")[0])}getDefaultCacheableResponsePlugin(){return this._defaultCacheableResponsePlugin||(this._defaultCacheableResponsePlugin=new d({statuses:[200]})),this._defaultCacheableResponsePlugin}async getCache(){return this._cache||(this._cache=await caches.open(this.cacheName)),this._cache}async match({request:e}){r({request:e});const t=await this.getCache();let s=await t.match(e,this.matchOptions);if(this.plugins.has("cacheWillMatch")){s=this.plugins.get("cacheWillMatch")[0].cacheWillMatch({request:e,cache:t,cachedResponse:s,matchOptions:this.matchOptions,cacheName:this.cacheName})}return s}async fetch({request:e}){"string"==typeof e?e=new Request(e):i({request:e},Request);const t=this.plugins.has("fetchDidFail")?e.clone():null;if(this.plugins.has("requestWillFetch"))for(let t of this.plugins.get("requestWillFetch")){const s=t.requestWillFetch({request:e});i({returnedPromise:s},Promise);const a=await s;i({returnedRequest:a},Request),e=a}try{return await fetch(e,this.fetchOptions)}catch(e){if(this.plugins.has("fetchDidFail"))for(let e of this.plugins.get("fetchDidFail"))e.fetchDidFail({request:t.clone()});throw e}}async fetchAndCache({request:e,waitOnCache:t,cacheKey:a,cacheResponsePlugin:c,cleanRedirects:o}){let n;r({request:e});const h=await this.fetch({request:e}),l=(this._userSpecifiedCachableResponsePlugin||c||this.getDefaultCacheableResponsePlugin()).cacheWillUpdate({request:e,response:h});if(l){const t=o&&h.redirected?await(({response:e})=>{i({response:e},Response);const t=e.clone();return("body"in t?Promise.resolve(t.body):t.blob()).then((e=>new Response(e,{headers:t.headers,status:t.status,statusText:t.statusText})))})({response:h}):h.clone();n=this.getCache().then((async s=>{let r;const i=a||e;if("opaque"!==h.type&&this.plugins.has("cacheDidUpdate")&&(r=await this.match({request:i})),await s.put(i,t),this.plugins.has("cacheDidUpdate"))for(let e of this.plugins.get("cacheDidUpdate"))await e.cacheDidUpdate({cacheName:this.cacheName,oldResponse:r,newResponse:t,url:"url"in i?i.url:i})}))}else if(!l&&t)throw s.createError("invalid-response-for-caching");return t&&n&&await n,h}}class w{constructor({requestWrapper:e,waitOnCache:t}={}){this.requestWrapper=e||new m,this.waitOnCache=!!t}handle({event:e,params:t}={}){throw Error("This abstract method must be implemented in a subclass.")}}e.CacheFirst=class extends w{async handle({event:e}={}){i({event:e},FetchEvent);return await this.requestWrapper.match({request:e.request})||await this.requestWrapper.fetchAndCache({request:e.request,waitOnCache:this.waitOnCache})}},e.CacheOnly=class extends w{async handle({event:e}={}){return i({event:e},FetchEvent),await this.requestWrapper.match({request:e.request})}},e.Handler=w,e.NetworkFirst=class extends w{constructor(e={}){super(e),this._cacheablePlugin=new d({statuses:[0,200]});const{networkTimeoutSeconds:t}=e;t&&(c({networkTimeoutSeconds:t},"number"),this.networkTimeoutSeconds=t)}async handle({event:e}={}){i({event:e},FetchEvent);const t=[];let a;this.networkTimeoutSeconds&&t.push(new Promise((t=>{a=setTimeout((()=>{t(this.requestWrapper.match({request:e.request}))}),1e3*this.networkTimeoutSeconds)})));const r=this.requestWrapper.fetchAndCache({request:e.request,waitOnCache:this.waitOnCache,cacheResponsePlugin:this._cacheablePlugin}).then((e=>(a&&clearTimeout(a),e||Promise.reject(s.createError("no-response-received"))))).catch((()=>this.requestWrapper.match({request:e.request})));return t.push(r),Promise.race(t)}},e.NetworkOnly=class extends w{async handle({event:e}={}){return i({event:e},FetchEvent),await this.requestWrapper.fetch({request:e.request})}},e.RequestWrapper=m,e.StaleWhileRevalidate=class extends w{constructor(e={}){super(e),this._cacheablePlugin=new d({statuses:[0,200]})}async handle({event:e}={}){i({event:e},FetchEvent);const t=this.requestWrapper.fetchAndCache({request:e.request,waitOnCache:this.waitOnCache,cacheResponsePlugin:this._cacheablePlugin}).catch((()=>Response.error()));return await this.requestWrapper.match({request:e.request})||await t}},e.getDefaultCacheName=g}(this.workbox.runtimeCaching=this.workbox.runtimeCaching||{});